---
title: "Séries Temporais - Análise descritiva, métodos simples de previsão e diagnóstico"
author: "Robson Bruno Dutra Pereira"
format:
  revealjs:
    incremental: true
    theme: serif
    smaller: true
    scrollable: true
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

## Estatísticas descritivas simples

```{r}
library(forecast)
library(tsibble)
library(dplyr)
library(tidyr)
library(fpp3)
library(ggplot2)
library(gt)
library(modelsummary)
library(cowplot)
library(curl)
theme_set(theme_bw())
```

- Algumas estatítiscas descritivas são úteis para uma avaliação inicial. 

```{r}
energia_2023 <- read.csv("BALANCO_ENERGIA_SUBSISTEMA_2023.csv", header = T, sep = ";")

energia_2023_tsibble <- energia_2023 |>
  filter(id_subsistena == "SIN") |>
  rename_with(~ tolower(gsub("val_ger", "", .x))) |>
  mutate(din_instante = as.POSIXct(din_instante, format = "%Y-%m-%d %H:%M:%S")) |>
  as_tsibble(index = din_instante) |>
  select(!c(id_subsistena,nom_subsistema,
            val_carga,val_intercambio)) |>
  pivot_longer(!din_instante)
```

```{r}
# energia_2023_tsibble |> glimpse()
```

::: columns
::: {.column width="70%"}
```{r}
energia_2023_tsibble |>
  autoplot(value) + labs(y = "", x = "")
```
:::

::: {.column width="30%"}
```{r}
energia_2023_tsibble |>
  features(value, list(mean = mean,
                       sd = sd)) |>
  arrange(mean) |> gt()
```
:::
:::

## Estatísticas descritivas simples

- Primeiro deixa 25\% das observações abaixo, o segundo ou a mediana deixa 50\% das observações abaixo, enquanto o terceiro e último deixa 75\% dos dados abaixo. 
- Mínimo (0\%) e máximo (100\%) de cada série são fornecidos.

```{r}
energia_2023_tsibble |> features(value, quantile) |> gt()
```

## Autocorrelação

- Estatística importante para avaliar sées temporais. 
- Deve-se defasar a série e calcular a correlação da série original com a série defasada. 
- Para uma defasagem (*lag*) de uma observação, $k=1$, calcula-se a correlação $r_1$ entre $y_t$ e $y_{t-1}$. 
- Para uma defasagem de duas observações, $k=2$, calcula-se a correlação $r_2$ entre $y_t$ e $y_{t-2}$ e assim sucessivamente.

$$
r_k = \frac{\sum_{t=k+1}^T (y_t-\bar{y})(y_{t-k}-\bar{y})}{\sum_{t=1}^T (y_t-\bar{y})^2}
$$

## Correlograma

- Correlograma: Gráfico que plota as autocorrelações para diferentes defasagens.
- Abaixo plota-se o correlograma da série de níveis de CO2 a partir de 2000, com até 100 defasagens.

```{r}
co2 <- read.csv("co2_mm_mlo.txt", header = TRUE, skip = 41, sep = "")
co2 <- co2[, 1:5]
colnames(co2) <- c("year", "month", "decimal.date", "monthly.averaged", "de-season.alized")
co2$Date <- as.Date(paste(co2$year, co2$month, "01", sep = "-"))

co2_tsibble <- tsibble(Date = co2$Date, 
                       CO2 = co2$monthly.averaged, 
                       index = Date)

co2_tsibble <- co2_tsibble |>
  filter(!is.na(CO2))

co2_tsibble <- co2_tsibble |>
  index_by(YearMonth = yearmonth(Date)) |>
  summarise(CO2 = sum(CO2, na.rm = TRUE))
```

```{r}
co2_tsibble |>
  filter(YearMonth >= yearmonth("2000", format = "%Y %m")) |>
  ACF(CO2, lag_max = 100) |>
  autoplot() + labs(x="")
```

## Correlograma

::: columns
::: {.column width="30%"}
- Figura a: ruído branco. Não apresenta autocorrelação significativa (correlograma na Figura d). 
- Figura b: padrão cíclico com sazonalidade de 24h (correlograma na Figura e). 
- Figura c: apresenta tendência linear positiva com sazonalidade anual (correlograma na Figura f).
:::

```{r}
carros <- read.csv("vendas_veiculos.csv", sep = ";")

carros_tsibble <- carros |>
  mutate(ano_mes = yearmonth(as.Date(data, format = "%d/%m/%Y"))) |>
  as_tsibble(index = ano_mes)
```

```{r}
tempo_sjdr <- read.csv("INMET_SJDR_2024.csv",
                       header=T)

tempo_sjdr$Hora..UTC. <- tempo_sjdr$Hora..UTC./100

tempo_sjdr <- tempo_sjdr[,1:3]

tempo_sjdr <- tempo_sjdr |>
  mutate(Data = dmy(Data)) |>
  mutate(Data = make_datetime(year(Data), month(Data), day(Data), Hora..UTC.)) |>
  select(!Hora..UTC.) |>
  as_tsibble(index = Data) |>
  rename(Temp = Temp..Ins...C.)
```

```{r}
# Definir a data inicial
data_inicial <- as.POSIXct("2024-05-01 00:00:00")

datas_especificas <- seq(from = data_inicial, by = "hour", length.out = 14*24)

tempo_sjdr_7_dias <- tempo_sjdr |>
  filter(Data %in% datas_especificas)

# tempo_sjdr_7_dias |>
#   autoplot(Temp) + 
#   labs(x = "", y = "Temp [°C]")
```

```{r}
ibov <- read.csv("Ibovespa_ InfoMoney_2024.csv",
                 header=T)

ibov <- ibov |>
  mutate(DATA = 1:nrow(ibov)) |>
  select(DATA,FECHAMENTO) |>
  as_tsibble(index = DATA)
```

::: {.column width="70%"}
```{r}
set.seed(77)
white <- tsibble(date = as.Date("2024-01-01") + 0:199,
                 value = rnorm(200)+70)

p1 <- white |> autoplot(value) + labs(x="",y="")
# p2 <- carros_tsibble |> autoplot(valor) + labs(x="",y="")
p3 <- tempo_sjdr_7_dias |> autoplot(Temp) + labs(x="",y="")
p4 <- co2_tsibble |> filter(YearMonth >= yearmonth("2000", format = "%Y %m")) |> autoplot(CO2) + labs(x="",y="")
p5 <- white |> ACF(value, lag_max = 30) |> autoplot()
# p6 <- carros_tsibble |> ACF(valor, lag_max = 30) |> autoplot()
p7 <- tempo_sjdr_7_dias |> ACF(Temp, lag_max = 30) |> autoplot()
p8 <- 
co2_tsibble |>
  filter(YearMonth >= yearmonth("2000", format = "%Y %m")) |>
  ACF(CO2, lag_max = 30) |>
  autoplot()

plot_grid(p1,p3,p4,p5,p7,p8, nrow=2,
              labels = as.vector(letters[1:6]),
          label_size = 10)
```
:::
:::


## Métodos simples de previsão: Média

::: columns
::: {.column width="50%"}
- Série histórica $y_1, ..., y_T$.

$$
\hat{y}_{T+h|T}=\frac{1}{T}\sum_{t=1}^Ty_t=\frac{y_1+y_2+...+y_T}{T}
$$

- Previsão com a média para três dias à frente na série temporal de produção de carros no Brasil.
:::

::: {.column width="50%"}
```{r}
carros_fit1 <- carros_tsibble |> 
  model(mean = MEAN(valor))
```

```{r}
carros_pred1 <- carros_fit1 |>
  forecast(h = "3 years")
# carros_pred1
```

```{r}
carros_pred1 |> 
  autoplot(carros_tsibble, level = NULL, linewidth=2) +
  labs(y = "Carros Produzidos", x = "")
```
:::
:::

## Métodos simples de previsão: Método ingênuo

::: columns
::: {.column width="50%"}
- Propõe prever as observações futuras como a última observação.

$$
\hat{y}_{T+h|T}=y_T
$$

- Previsão com o método ingênuo para três dias à frente na série temporal de produção de carros no Brasil.
:::

::: {.column width="50%"}
```{r}
carros_fit2 <- carros_tsibble |> 
  model(naive = NAIVE(valor))

carros_pred2 <- carros_fit2 |>
  forecast(h = "3 years")
# carros_pred2

carros_pred2 |> 
  autoplot(carros_tsibble, level = NULL, linewidth=2) +
  labs(y = "Carros Produzidos", x = "")
```
:::
:::

## Métodos simples de previsão: Ingênuo sazonal

::: columns
::: {.column width="50%"}
- Indicado para séries muito sazonais. 
- Propõe prever as observações futuras iguais aos períodos das estações anteriores
- $m$: período sazonal; $k$: parte inteira de $(h-1)/m$ (número completo de períodos antes de $T+h$).

$$
\hat{y}_{T+h|T}=y_{T+h-m(k+1)}
$$

- Previsão com o método ingênuo sazonal para três dias à frente na série temporal de produção de carros no Brasil.
:::

::: {.column width="50%"}
```{r}
carros_fit3 <- carros_tsibble |> 
  model(snaive = SNAIVE(valor ~ lag("year")))

carros_pred3 <- carros_fit3 |>
  forecast(h = "3 years")
# carros_pred3

carros_pred3 |> 
  autoplot(carros_tsibble, level = NULL, linewidth=1) +
  labs(y = "Carros Produzidos", x = "")
```
:::
:::

## Métodos simples de previsão

- Conjunto de dados de temperatura instantânea das duas primeiras semanas de Maio de 2024 para a cidade de São joão del-Rei. 
- Dados da primeira semana para treinar os modelos. 
- Previsões plotadas para a semana seguinte juntamente com os dados. 

```{r}
train <- tempo_sjdr_7_dias |>
  filter_index("2024-05-01 00:00:00" ~ "2024-05-07 23:00:00")

temp_fit <- train |>
  model(
    media = MEAN(Temp),
    Ingenuo = NAIVE(Temp),
    `Ingenuo sazonal` = SNAIVE(Temp)
  )

temp_fc <- temp_fit |> forecast(h = 7*24)
temp_fc |>
  autoplot(train, level = NULL, linewidth=1) +
  autolayer(
    filter_index(tempo_sjdr_7_dias, "2024-05-08 00:00:00" ~ .),
    colour = "black") +
  labs(y = "Temp [°C]",x="") +
  guides(colour = guide_legend(title = "Previsao"))
```

::: aside
https://tempo.inmet.gov.br/TabelaEstacoes/A001
:::

## Métodos simples de previsão: Deriva

::: columns
::: {.column width="50%"}
- Variação do ingênuo que permite a previsão de observações com tendência de crescimento ou decréscimo segundo a deriva observada entre a primeira e última observação.

- Previsão com o método da deriva para três dias à frente na série temporal de produção de carros no Brasil.

$$
\hat{y}_{T+h|T} = y_T + \frac{h}{T-1}\sum_{t=2}^T(y_t-y_{t-1}) =y_T+h \bigg(\frac{y_T-y_1}{T-1}\bigg) 
$$
:::

::: {.column width="50%"}
```{r}
carros_fit4 <- carros_tsibble |> 
  model(drift = RW(valor ~ drift()))

carros_pred4 <- carros_fit4 |>
  forecast(h = "3 years")
# carros_pred4

primeiro_ponto <- carros_tsibble |> slice(1)
ultimo_ponto <- carros_tsibble |> slice(n())

carros_pred4 |> 
  autoplot(carros_tsibble, level = NULL, linewidth=2) +
  geom_segment(data = carros_tsibble, 
               mapping = aes(x = primeiro_ponto$ano_mes, 
                   y = primeiro_ponto$valor,
                   xend = ultimo_ponto$ano_mes, 
                   yend = ultimo_ponto$valor),
               color = "blue", linetype = 2) +
  labs(y = "Carros Produzidos", x = "")
```
:::
:::

## Resíduos e valores previstos

- Valores previstos $\hat{y}_{t|t-1}$, implicando que a previsão de $\hat{y}_{t}$ é baseada nas observações $y_1, ..., y_{t-1}$.

- Resíduos (erros) de uma série temporal são calculados como a diferença entre o observado e o previsto em cada instante de tempo.

$$e_t=y_t-\hat{y}_t$$

- Valores previstos (`.fitted`) e os resíduos (`.resid`) para as previsões obtidas com o método Ingênuo sazonal para as últimas observações.

```{r}
augment(temp_fit) |> 
  filter(.model == "Ingenuo sazonal") |>
  select(!c(.model, .innov)) |>
  tail() |> gt()
```

## Diagnósticos dos resíduos

Os resíduos de um modelo de séries temporais devem ser:

- Não correlacionados.

- Com média nula.


É interessante, porém não-obrigatório, que os resíduos sejam:

3. Homocedasticos.

4. Normalmente distribuídos.

## Diagnósticos dos resíduos

- Série histórica de 187 observações do índice Ibovespa.

```{r}
ibov |>
  autoplot(FECHAMENTO) + 
  labs(y = "Índice Ibovespa B3 [R$]", x = "") 
```

::: aside
https://www.infomoney.com.br/cotacoes/b3/indice/ibovespa/historico/
:::

## Diagnósticos dos resíduos

- Previsão de índices da bolsa com o método Ingênuo. 
- $e_t = y_t - \hat{y}_t = y_t - y_{t-1}$.

```{r}
aug <- ibov |>
  model(NAIVE(FECHAMENTO)) |>
  augment()
```

Gráfico de resíduos, correlograma e histograma dos resíduos.

```{r}
ibov |>
 model(NAIVE(FECHAMENTO)) |>
 gg_tsresiduals()
```

## Testes de autocorrelação

- Testes para averiguar se as $l$ primeiras autocorrelações são diferentes do que se esperaria para um ruído branco. 

**Box-Pierce**

$$
Q = T\sum_{k=1}^l r_k^2
$$

- Sugere-se $l=10$ autocorrelações para séries não sazonais e $l=2m$ para casos sazonais, com $m$ sendo o período sazonal. 
- Teste não é adequado para $l$ auto, sugerindo-se no máximo $l=T/5$. 

## Testes de autocorrelação

**Ljung-Box**

$$
Q^* = T(T+2)\sum_{k=1}^l (T-k)^{-1}r_k^2
$$

- Alto valor de $Q^*$ (ou $Q$) sugere que as autocorrelações não vem de um ruído branco.
- Para decisão, considera-se que $Q^*$ (ou $Q$) segue a distribuição $\chi^2$ com $l$ graus de liberdade. 

## Testes de autocorrelação

- valor $Q$ e $Q^*$ para os resíduos do modelo Ingênuo para os dados do índice Ibovespa. 
- Os testes indicam que as autocorrelações dos resíduos não diferem das de ruído branco. 

```{r}
aug |> features(.innov, box_pierce, lag = 10) |> gt()

aug |> features(.innov, ljung_box, lag = 10) |> gt()
```

## Intervalos de previsão

- Intervalo de previsão com nível de probabilidade ou confiança de interesse. 
- Para, por exemplo, um intervalo de previsão de 95\%, os limites garantem que o valor previsto estará entre eles com 95\% de confiança.

- Intervalo de previsão para $h$ passos à frente com 95\% de confianca.

$$
\hat{y}_{T+h|T} \pm1,96 \hat\sigma_h,
$$

- $z_{\gamma=0,95} = 1,96$: valor do quantil na distribuição normal-padrão $z$, com 0,95 de probabilidade ou confiança. 

## Intervalos de previsão

- Desvio-padrão para previsões com $h=1$ (um passo a frente): desvio-padrão dos resíduos.
- $K$: número de parâmetros do modelo; $M$: número de valores ausentes nos resíduos (para o método ingênuo e o da deriva, por exemplo, $M=1$, uma vez que a primeira observação não pode ser estimada).

$$
\hat\sigma = \sqrt{\frac{1}{T-K-M}\sum_{t=1}^T e_t^2}
$$

## Intervalos de previsão

- Previsões com $h>1$ a estimativa de $\sigma_h$ é mais complexa. 
- Equações para estimar o desvio-padrão para os métodos *benchmarking* até aqui expostos.
- $m$: período sazonal; $k$: parte inteira de $(h−1)/m$.

| Método          | desvio-padrão para $h$ previsões               |
|-----------------|:-----------------------------------------------|
| Média           | $\hat\sigma_h = \hat\sigma\sqrt{1+1/T}$        | 
| Ingênuo         | $\hat\sigma_h = \hat\sigma\sqrt{h}$            |
| Ingênuo sazonal | $\hat\sigma_h = \hat\sigma\sqrt{k+1}$          |
| Deriva          | $\hat\sigma_h = \hat\sigma\sqrt{h(1+h/(T-1))}$ |

## Intervalos de previsão

- Intervalos de confiança de 80 e 95\% para $h=10$ períodos para o índice Ibovespa.

```{r}
ibov |>
  model(RW(FECHAMENTO ~ drift())) |>
  forecast(h = 10) |>
  hilo() |> gt()
```

## Intervalos de previsão

- Intervalos de confiança de 80 e 95\% para $h=10$ períodos para o índice Ibovespa.

```{r}
ibov |>
  model(RW(FECHAMENTO ~ drift())) |>
  forecast(h = 10) |>
  autoplot(ibov) + 
  labs(y = "Índice Ibovespa B3 [R$]", x = "") 
```

## Transformações

- Usadas nas séries temporais para auxiliar no cumprimento das pressuposições sobre os resíduos.
- Ou que alguma variação que aumenta ou cresce com o tempo seja corrigida. 

- Transformação logarítima. 
- Série original: $y_1, y_2, ..., y_T$. 
- Série transformada : $w_1, w_2, ..., w_T$, com $w_t =log(y_t)$. 

Transformação de **Box-Cox**

$$
w_t = \Bigg\{ \begin{matrix}
                \text{log}(y_t), \text{ }\lambda=0 \\
                (\text{sign}(y_t)|y_t|^\lambda-1)/\lambda, \text{ }\lambda>0
             \end{matrix}
$$

onde $\text{sign}(y_t) = 1$ se $y\geq0$ e $\text{sign}(y_t) =-1$, caso contrário.

## Transformações

- Série temporal das ações da vale (VALE3). 
- Pode-se observar que a série apresenta alta variabilidade, especialmente de 2021 a 2023.

```{r}
vale <- read.csv("VALE3.csv", header = T, dec=",")

vale_ts <- tsibble(Date = as.Date(vale$Data,
                                  format = "%d.%m.%Y"),
                   Valor = vale$Último,
                   index = Date)
```

```{r}
vale_ts <- vale_ts |>
  filter(year(Date) > 2015)

vale_ts |>  
  autoplot(Valor) + labs(x="")
```

::: aside
https://br.investing.com/equities/vale-on-n1-historical-data
:::

## Avaliação de modelos de séries temporais

- A avaliação ideal deve ser baseada no desempenho do modelo em novos dados e não nos valores residuais. 
- Deve-se considerar dados separados para teste do modelo ou em dados futuros. 
- Não deve-se considerar dados usados para estimar (treinar) o modelo para testá-lo.

- Exemplo: Separação das primeiras 75\% observações em treino e os 25\% restantes para teste.

```{r}
data.frame(y=0, x=1:20,
           id = c(rep("treino", 20*.75), 
                rep("teste", 20*.25))) |>
  ggplot(aes(x=x, y=y, col=id)) +
  theme_minimal() +
  geom_point() + labs(x="Tempo",y="", col="") +
  theme(axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank()) + 
  coord_fixed(ratio=3)
```

## Avaliação de modelos de séries temporais

- Erro de previsão (não confundir com resíduo).

$$
e_{T+h} = y_{T+h} - \hat{y}_{T+h|T}
$$

- Onde:  dados de treino $y_1,...,y_T$ e de teste  $y_{T+1}, y_{T+2}, ...$.

- Métricas mais comuns para avaliar os modelos.

| Métrica  | Fórmula                                         |
|----------|:------------------------------------------------|
| MAE      | $\text{MAE = mean}(|e_t|)$                      | 
| RMSE     | $\text{RMSE = }\sqrt{\text{mean}(e_t^2)}$       |
| MAPE     | $\text{MAPE = mean}(|p_t|)$, $p_t = 100e_t/y_t$ |
| MASE     | $\text{MAE = mean}(|q_j|)$                      |

## Avaliação de modelos de séries temporais

- Desempenho dos três métodos considerados nos dados de temperatura instantânea de São João-del-Rei.

```{r}
last_days <- tempo_sjdr_7_dias |>
  filter_index("2024-05-08 00:00:00" ~ .)

accuracy(temp_fc, last_days) |>
  select(.model,RMSE,MAE,MAPE) |> gt()
```